<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ThrustEd</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        .resizer {
            cursor: col-resize;
        }
        .sprite-selected {
            border: 2px solid #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col">
    <header class="bg-blue-600 text-white p-2">
        <div class="text-xl font-bold mt-2">
            ThrustEd
            <button id="newFile" class="bg-blue-500 hover:bg-blue-700 px-3 py-1 rounded">New</button>
            <input type="file" id="loadFile" accept=".json" class="hidden">
            <button id="loadFileBtn" class="bg-yellow-500 hover:bg-yellow-700 px-3 py-1 rounded">Load</button>
            <button id="saveFile" class="bg-green-500 hover:bg-green-700 px-3 py-1 rounded">Save</button>
     </div>
       
    </header>

    <div class="flex-1 flex">
        <!-- Canvas Area -->
        <div id="canvasArea" class="bg-white border-r-2">
            <div class="p-4">
                <div class="mb-4 flex space-x-2 flex-wrap">
                    <label>Canvas Width: <input id="canvasWidth" type="number" value="20" class="border px-2 py-1 w-16"></label>
                    <label>Canvas Height: <input id="canvasHeight" type="number" value="15" class="border px-2 py-1 w-16"></label>
                    <label>Tile Size: <input id="tileSize" type="number" value="32" class="border px-2 py-1 w-16"></label>
                    <button id="updateCanvas" class="bg-blue-500 text-white px-3 py-1 rounded">Update</button>
                </div>
                <div id="canvasAreaWrapper">
                  <canvas id="mainCanvas" class="border border-gray-400 block"></canvas>
                </div>
            </div>
        </div>

        <!-- Resizer -->
        <div id="resizer" class="w-1 bg-gray-400 resizer hover:bg-gray-600"></div>

        <!-- Toolbox -->
    <div id="toolbox" class="bg-gray-50">
            <div class="p-4">
                <!-- Layers Panel -->
                <div class="mb-6">
                    <h3 class="font-bold mb-2">Layers</h3>
                    <div class="mb-2">
                        <button id="addTileLayer" class="bg-green-500 text-white px-2 py-1 rounded text-sm mr-1">Add Tile Layer</button>
                        <button id="addFreeLayer" class="bg-blue-500 text-white px-2 py-1 rounded text-sm">Add Free Layer</button>
                    </div>
                    <div id="layersList" class="space-y-2"></div>
                </div>

                <!-- Tools Panel -->
                <div id="toolsPanel">
                    <h3 class="font-bold mb-2">Tools</h3>
                    <div id="tileGridTools" class="hidden">
                        <h4 class="font-semibold mb-2">Tile Grid Tools</h4>
                        <div class="grid grid-cols-8 gap-1 mb-2">
                            <!-- Tile palette will be populated here -->
                        </div>
                        <button id="fillScreenBtn" class="bg-gray-300 hover:bg-gray-400 px-2 py-1 rounded text-xs">Fill Screen</button>
                    </div>
                    <div id="freeGridTools" class="hidden">
                        <h4 class="font-semibold mb-2">Free Grid Tools</h4>
                        <div>
                            <label>Sprite ID: <input id="spriteId" type="text" class="border px-2 py-1 w-full mb-2" placeholder="auto-generated"></label>
                            <label>Type:
                                <select id="spriteType" class="border px-2 py-1 w-full mb-2">
                                    <option value="Player">Player</option>
                                    <option value="Fuel">Fuel</option>
                                    <option value="Turret">Turret</option>
                                </select>
                            </label>
                            <div class="text-sm text-gray-600 mb-2">Click canvas to add sprite</div>
                            <div id="selectedSpriteInfo" class="hidden border-t pt-2 mt-2">
                                <h5 class="font-semibold">Selected Sprite:</h5>
                                <div id="spriteDetails"></div>
                                <button id="editSpriteProps" class="bg-blue-500 text-white px-2 py-1 rounded text-sm mt-2">Edit Properties</button>
                                <button id="deleteSpriteBtn" class="bg-red-500 text-white px-2 py-1 rounded text-sm mt-2 ml-2">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class Layer {
            constructor(name, type) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.name = name;
                this.type = type; // 'tilegrid' or 'freegrid'
                this.visible = true;
                this.data = type === 'tilegrid' ? [] : [];
            }
        }

        class CanvasEditor {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvasWidth = 20;
                this.canvasHeight = 15;
                this.tileSize = 32;
                this.layers = [];
                this.activeLayer = null;
                this.selectedTile = 0;
                this.selectedSprite = null;
                this.isResizing = false;
                this.monacoEditor = null;
                
                this.initCanvas();
                this.initEventListeners();
                this.initResizer();
                this.generateTilePalette();
                this.initMonacoEditor();
            }

            initCanvas() {
                this.canvas.width = this.canvasWidth * this.tileSize;
                this.canvas.height = this.canvasHeight * this.tileSize;
                this.redraw();
            }

            initEventListeners() {
                document.getElementById('updateCanvas').addEventListener('click', () => {
                    this.canvasWidth = parseInt(document.getElementById('canvasWidth').value);
                    this.canvasHeight = parseInt(document.getElementById('canvasHeight').value);
                    this.tileSize = parseInt(document.getElementById('tileSize').value);
                    this.initCanvas();
                });

                document.getElementById('addTileLayer').addEventListener('click', () => {
                    this.addLayer('Tile Layer', 'tilegrid');
                });

                document.getElementById('addFreeLayer').addEventListener('click', () => {
                    this.addLayer('Free Layer', 'freegrid');
                });

                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                // Fill screen button
                document.getElementById('fillScreenBtn').addEventListener('click', () => {
                    if (this.activeLayer && this.activeLayer.type === 'tilegrid') {
                        this.fillScreen();
                    }
                });

                // Sprite editing buttons
                document.getElementById('editSpriteProps').addEventListener('click', () => {
                    if (this.selectedSprite) {
                        this.openSpritePropertiesEditor();
                    }
                });

                document.getElementById('deleteSpriteBtn').addEventListener('click', () => {
                    if (this.selectedSprite && this.activeLayer) {
                        this.activeLayer.data = this.activeLayer.data.filter(s => s !== this.selectedSprite);
                        this.selectedSprite = null;
                        this.updateSelectedSpriteInfo();
                        this.redraw();
                    }
                });

                // File operations
                document.getElementById('newFile').addEventListener('click', () => this.newFile());
                document.getElementById('saveFile').addEventListener('click', () => this.saveFile());
                document.getElementById('loadFileBtn').addEventListener('click', () => {
                    document.getElementById('loadFile').click();
                });
                document.getElementById('loadFile').addEventListener('change', (e) => this.loadFile(e));
            }

            initResizer() {
                const resizer = document.getElementById('resizer');
                const canvasArea = document.getElementById('canvasArea');
                const toolbox = document.getElementById('toolbox');
                
                resizer.addEventListener('mousedown', (e) => {
                    this.isResizing = true;
                    document.addEventListener('mousemove', this.handleResize);
                    document.addEventListener('mouseup', () => {
                        this.isResizing = false;
                        document.removeEventListener('mousemove', this.handleResize);
                    });
                });
            }

            initMonacoEditor() {
                // Monaco will be loaded dynamically when needed
                console.log('Monaco Editor will be loaded when JSON editor is opened');
            }

            handleResize = (e) => {
                if (!this.isResizing) return;
                const container = document.querySelector('.flex-1.flex');
                const containerRect = container.getBoundingClientRect();
                const newWidth = ((e.clientX - containerRect.left) / containerRect.width) * 100;
                
                // Limit canvas area between 30% and 85%
                if (newWidth > 30 && newWidth < 85) {
                    const canvasArea = document.getElementById('canvasArea');
                    canvasArea.style.width = newWidth + '%';
                }
            }

            addLayer(name, type) {
                const layer = new Layer(name, type);
                if (type === 'tilegrid') {
                    // Fill with transparent (0)
                    layer.data = new Array(this.canvasWidth * this.canvasHeight).fill(0);
                } else if (type === 'freegrid') {
                    // Initialize empty array for sprites
                    layer.data = [];
                }
                
                this.layers.push(layer);
                this.activeLayer = layer;
                this.selectedSprite = null; // Clear any selected sprite
                this.updateLayersList();
                this.updateToolsPanel();
                this.redraw();
            }

            updateLayersList() {
                const layersList = document.getElementById('layersList');
                layersList.innerHTML = '';
                
                this.layers.forEach((layer, index) => {
                    const layerDiv = document.createElement('div');
                    layerDiv.className = `p-2 border rounded ${this.activeLayer === layer ? 'bg-blue-100' : 'bg-white'}`;
                    layerDiv.innerHTML = `
                        <div class="flex justify-between items-center">
                            <input type="text" value="${layer.name}" class="font-semibold bg-transparent" onchange="editor.renameLayer('${layer.id}', this.value)">
                            <div class="space-x-1">
                                <button onclick="editor.toggleLayerVisibility('${layer.id}')" class="text-sm ${layer.visible ? 'text-green-600' : 'text-red-600'}">
                                    ${layer.visible ? 'üëÅ' : 'üëÅ‚Äçüó®'}
                                </button>
                                <button onclick="editor.moveLayer('${layer.id}', ${index - 1})" class="text-sm" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                                <button onclick="editor.moveLayer('${layer.id}', ${index + 1})" class="text-sm" ${index === this.layers.length - 1 ? 'disabled' : ''}>‚Üì</button>
                                <button onclick="editor.removeLayer('${layer.id}')" class="text-sm text-red-600">üóë</button>
                            </div>
                        </div>
                        <div class="text-xs text-gray-500 mt-1">${layer.type}</div>
                    `;
                    layerDiv.addEventListener('click', () => {
                        this.activeLayer = layer;
                        this.updateLayersList();
                        this.updateToolsPanel();
                    });
                    layersList.appendChild(layerDiv);
                });
            }

            updateToolsPanel() {
                const tileGridTools = document.getElementById('tileGridTools');
                const freeGridTools = document.getElementById('freeGridTools');
                
                if (this.activeLayer && this.activeLayer.type === 'tilegrid') {
                    tileGridTools.classList.remove('hidden');
                    freeGridTools.classList.add('hidden');
                    this.selectedSprite = null;
                } else if (this.activeLayer && this.activeLayer.type === 'freegrid') {
                    tileGridTools.classList.add('hidden');
                    freeGridTools.classList.remove('hidden');
                } else {
                    tileGridTools.classList.add('hidden');
                    freeGridTools.classList.add('hidden');
                    this.selectedSprite = null;
                }
                this.updateSelectedSpriteInfo();
            }

            updateSelectedSpriteInfo() {
                const selectedSpriteInfo = document.getElementById('selectedSpriteInfo');
                const spriteDetails = document.getElementById('spriteDetails');
                
                if (this.selectedSprite) {
                    selectedSpriteInfo.classList.remove('hidden');
                    spriteDetails.innerHTML = `
                        <div><strong>ID:</strong> ${this.selectedSprite.id}</div>
                        <div><strong>Type:</strong> ${this.selectedSprite.type}</div>
                        <div><strong>Position:</strong> (${Math.round(this.selectedSprite.x)}, ${Math.round(this.selectedSprite.y)})</div>
                        <div><strong>Properties:</strong> ${Object.keys(this.selectedSprite.properties || {}).length} items</div>
                    `;
                } else {
                    selectedSpriteInfo.classList.add('hidden');
                }
            }

            openSpritePropertiesEditor() {
                if (!this.selectedSprite) return;
                
                const modal = document.getElementById('jsonModal');
                const editor = document.getElementById('jsonEditor');
                const title = modal.querySelector('h2');
                
                title.textContent = `Edit Properties for ${this.selectedSprite.id}`;
                const jsonString = JSON.stringify(this.selectedSprite.properties || {}, null, 2);
                
                // Show modal first
                modal.style.display = 'block';
                
                // Try to use Monaco if available, otherwise fallback to textarea
                const trySetMonaco = () => {
                    const monacoContainer = document.getElementById('monacoContainer');
                    if (window.monacoEditor && typeof monaco !== 'undefined') {
                        window.monacoEditor.setValue(jsonString);
                        monacoContainer.style.display = 'block';
                        editor.style.display = 'none';
                        window.monacoEditor.layout();
                    } else {
                        editor.value = jsonString;
                        monacoContainer.style.display = 'none';
                        editor.style.display = 'block';
                    }
                };
                
                // Wait a bit for Monaco to be available if it's loading
                setTimeout(trySetMonaco, 100);
                
                // Override save handler for sprite properties
                const saveBtn = document.getElementById('jsonSave');
                const cancelBtn = document.getElementById('jsonCancel');
                
                const newSaveHandler = () => {
                    try {
                        const newJsonString = (window.monacoEditor && typeof monaco !== 'undefined') ? 
                            window.monacoEditor.getValue() : 
                            editor.value;
                        const newProperties = JSON.parse(newJsonString);
                        this.selectedSprite.properties = newProperties;
                        modal.style.display = 'none';
                        this.updateSelectedSpriteInfo();
                        // Remove event listeners
                        saveBtn.removeEventListener('click', newSaveHandler);
                        cancelBtn.removeEventListener('click', newCancelHandler);
                    } catch (err) {
                        alert('Invalid JSON: ' + err.message);
                    }
                };
                
                const newCancelHandler = () => {
                    modal.style.display = 'none';
                    // Remove event listeners
                    saveBtn.removeEventListener('click', newSaveHandler);
                    cancelBtn.removeEventListener('click', newCancelHandler);
                };
                
                saveBtn.addEventListener('click', newSaveHandler);
                cancelBtn.addEventListener('click', newCancelHandler);
            }

            // Commodore 64 palette (0=striped transparent, 1=black, 2=white, ... 14=light blue, exclude last color)
            getC64Palette() {
                return [
                    'transparent', // 0 striped transparent
                    '#000000', // 1 Black
                    '#FFFFFF', // 2 White
                    '#880000', // 3 Red
                    '#AAFFEE', // 4 Cyan
                    '#CC44CC', // 5 Purple
                    '#00CC55', // 6 Green
                    '#0000AA', // 7 Blue
                    '#EEEE77', // 8 Yellow
                    '#DD8855', // 9 Orange
                    '#664400', // 10 Brown
                    '#FF7777', // 11 Light red
                    '#333333', // 12 Dark gray
                    '#777777', // 13 Medium gray
                    '#AAFF66', // 14 Light green
                    '#0088FF'  // 15 Light blue (excluded from palette below)
                ];
            }

            generateTilePalette() {
                const tileGridTools = document.getElementById('tileGridTools');
                const palette = tileGridTools.querySelector('.grid');
                palette.innerHTML = '';
                const c64Palette = this.getC64Palette();
                // Only 0-14 (15 colors, last excluded)
                for (let i = 0; i < 15; i++) {
                    const tile = document.createElement('div');
                    tile.className = 'w-8 h-8 border border-gray-300 cursor-pointer flex items-center justify-center';
                    if (i === 0) {
                        tile.classList.add('c64-tile-transparent');
                        tile.title = 'Transparent (0)';
                    } else {
                        tile.style.backgroundColor = c64Palette[i];
                        tile.title = `Color ${i}`;
                    }
                    tile.addEventListener('click', () => {
                        this.selectedTile = i;
                        palette.querySelectorAll('div').forEach(t => t.classList.remove('ring-2', 'ring-blue-500'));
                        tile.classList.add('ring-2', 'ring-blue-500');
                    });
                    if (i === 0) tile.classList.add('ring-2', 'ring-blue-500');
                    palette.appendChild(tile);
                }
            }

            fillScreen() {
                if (!this.activeLayer || this.activeLayer.type !== 'tilegrid') return;
                const color = this.selectedTile;
                this.activeLayer.data = new Array(this.canvasWidth * this.canvasHeight).fill(color);
                this.redraw();
            }

            handleCanvasClick(e) {
                if (!this.activeLayer) return;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.activeLayer.type === 'tilegrid') {
                    const tileX = Math.floor(x / this.tileSize);
                    const tileY = Math.floor(y / this.tileSize);
                    const index = tileY * this.canvasWidth + tileX;
                    if (index >= 0 && index < this.activeLayer.data.length) {
                        this.activeLayer.data[index] = this.selectedTile;
                        this.redraw();
                    }
                } else if (this.activeLayer.type === 'freegrid') {
                    // Check if clicking on an existing sprite
                    let clickedSprite = null;
                    for (let sprite of this.activeLayer.data) {
                        if (Math.abs(sprite.x - x) < 16 && Math.abs(sprite.y - y) < 16) {
                            clickedSprite = sprite;
                            break;
                        }
                    }
                    
                    if (clickedSprite) {
                        // Select sprite
                        this.selectedSprite = clickedSprite;
                        this.updateSelectedSpriteInfo();
                        this.redraw();
                    } else {
                        // Add new sprite
                        const spriteType = document.getElementById('spriteType').value;
                        let spriteId = document.getElementById('spriteId').value.trim();
                        
                        if (!spriteId) {
                            // Generate default ID
                            const count = this.activeLayer.data.filter(s => s.type === spriteType).length;
                            spriteId = `${spriteType}-${count + 1}`;
                        }
                        
                        const newSprite = {
                            id: spriteId,
                            type: spriteType,
                            x: x,
                            y: y,
                            properties: {}
                        };
                        
                        this.activeLayer.data.push(newSprite);
                        this.selectedSprite = newSprite;
                        document.getElementById('spriteId').value = ''; // Clear for next sprite
                        this.updateSelectedSpriteInfo();
                        this.redraw();
                    }
                }
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.ctx.strokeStyle = '#e5e7eb';
                this.ctx.lineWidth = 1;
                for (let x = 0; x <= this.canvasWidth; x++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x * this.tileSize, 0);
                    this.ctx.lineTo(x * this.tileSize, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y <= this.canvasHeight; y++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y * this.tileSize);
                    this.ctx.lineTo(this.canvas.width, y * this.tileSize);
                    this.ctx.stroke();
                }
                
                // Draw layers
                const c64Palette = this.getC64Palette();
                this.layers.forEach(layer => {
                    if (!layer.visible) return;
                    
                    if (layer.type === 'tilegrid') {
                        layer.data.forEach((tileId, index) => {
                            const x = (index % this.canvasWidth) * this.tileSize;
                            const y = Math.floor(index / this.canvasWidth) * this.tileSize;
                            if (tileId === 0) {
                                // Draw striped transparent
                                this.ctx.save();
                                this.ctx.fillStyle = this.ctx.createPattern(CanvasEditor.getStripedPattern(this.tileSize), 'repeat');
                                this.ctx.fillRect(x, y, this.tileSize, this.tileSize);
                                this.ctx.restore();
                            } else {
                                this.ctx.fillStyle = c64Palette[tileId] || '#000';
                                this.ctx.fillRect(x, y, this.tileSize, this.tileSize);
                            }
                        });
                    } else if (layer.type === 'freegrid') {
                        layer.data.forEach(sprite => {
                            const isSelected = sprite === this.selectedSprite;
                            
                            this.ctx.save();
                            
                            // Draw sprite background
                            this.ctx.fillStyle = isSelected ? '#3b82f6' : '#6b7280';
                            this.ctx.fillRect(sprite.x - 16, sprite.y - 16, 32, 24);
                            
                            if (isSelected) {
                                // Draw selection border
                                this.ctx.strokeStyle = '#1d4ed8';
                                this.ctx.lineWidth = 2;
                                this.ctx.strokeRect(sprite.x - 18, sprite.y - 18, 36, 28);
                            }
                            
                            // Draw sprite ID
                            this.ctx.fillStyle = 'white';
                            this.ctx.font = '10px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.fillText(sprite.id, sprite.x, sprite.y - 4);
                            
                            // Draw sprite type
                            this.ctx.fillStyle = '#fef08a';
                            this.ctx.font = '8px Arial';
                            this.ctx.fillText(sprite.type, sprite.x, sprite.y + 6);
                            
                            this.ctx.restore();
                        });
                    }
                });
            }

            // Static method for striped pattern
            static getStripedPattern(size) {
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = patternCanvas.height = size;
                const pctx = patternCanvas.getContext('2d');
                pctx.fillStyle = '#fff';
                pctx.fillRect(0, 0, size, size);
                pctx.strokeStyle = '#ccc';
                for (let i = -size; i < size * 2; i += 6) {
                    pctx.beginPath();
                    pctx.moveTo(i, 0);
                    pctx.lineTo(i + size, size);
                    pctx.stroke();
                }
                return patternCanvas;
            }
        
            renameLayer(layerId, newName) {
                const layer = this.layers.find(l => l.id === layerId);
                if (layer) {
                    layer.name = newName;
                    this.updateLayersList();
                }
            }

            toggleLayerVisibility(layerId) {
                const layer = this.layers.find(l => l.id === layerId);
                if (layer) {
                    layer.visible = !layer.visible;
                    this.updateLayersList();
                    this.redraw();
                }
            }

            moveLayer(layerId, newIndex) {
                const currentIndex = this.layers.findIndex(l => l.id === layerId);
                if (currentIndex === -1 || newIndex < 0 || newIndex >= this.layers.length) return;
                
                const layer = this.layers.splice(currentIndex, 1)[0];
                this.layers.splice(newIndex, 0, layer);
                this.updateLayersList();
                this.redraw();
            }

            removeLayer(layerId) {
                const index = this.layers.findIndex(l => l.id === layerId);
                if (index !== -1) {
                    this.layers.splice(index, 1);
                    if (this.activeLayer && this.activeLayer.id === layerId) {
                        this.activeLayer = this.layers[0] || null;
                    }
                    this.updateLayersList();
                    this.updateToolsPanel();
                    this.redraw();
                }
            }

            newFile() {
                this.layers = [];
                this.activeLayer = null;
                this.updateLayersList();
                this.updateToolsPanel();
                this.redraw();
            }

            saveFile() {
                const data = {
                    canvasWidth: this.canvasWidth,
                    canvasHeight: this.canvasHeight,
                    tileSize: this.tileSize,
                    layers: this.layers
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'canvas-editor-project.json';
                a.click();
                URL.revokeObjectURL(url);
            }

            loadFile(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.canvasWidth = data.canvasWidth;
                        this.canvasHeight = data.canvasHeight;
                        this.tileSize = data.tileSize;
                        this.layers = data.layers;
                        this.activeLayer = this.layers[0] || null;
                        
                        document.getElementById('canvasWidth').value = this.canvasWidth;
                        document.getElementById('canvasHeight').value = this.canvasHeight;
                        document.getElementById('tileSize').value = this.tileSize;
                        
                        this.initCanvas();
                        this.updateLayersList();
                        this.updateToolsPanel();
                    } catch (error) {
                        alert('Invalid file format');
                    }
                };
                reader.readAsText(file);
            }
        }

        // --- Enhanced JSON Editor Modal with Monaco ---
        (function() {
            const modal = document.createElement('div');
            modal.id = 'jsonModal';
            modal.style.display = 'none';
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100vw';
            modal.style.height = '100vh';
            modal.style.background = 'rgba(0,0,0,0.5)';
            modal.style.zIndex = '1000';
            modal.innerHTML = `
                <div style="background:#fff;max-width:800px;max-height:80vh;margin:5vh auto;padding:20px;position:relative;display:flex;flex-direction:column;">
                    <h2 class="font-bold mb-4">Edit Layer JSON</h2>
                    <div id="monacoContainer" style="height:400px;border:1px solid #ccc;flex-grow:1;display:none;"></div>
                    <textarea id="jsonEditor" style="width:100%;height:300px;font-family:monospace;"></textarea>
                    <div class="mt-4 flex justify-end space-x-2">
                        <button id="jsonCancel" class="bg-gray-300 hover:bg-gray-400 px-4 py-2 rounded">Cancel</button>
                        <button id="jsonSave" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">Save</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            let monacoEditor = null;
            let monacoLoaded = false;
            let monacoLoading = false;

            // Load Monaco Editor dynamically
            function loadMonaco() {
                return new Promise((resolve, reject) => {
                    if (monacoLoaded) {
                        resolve();
                        return;
                    }
                    
                    if (monacoLoading) {
                        // Wait for existing load
                        const checkLoaded = setInterval(() => {
                            if (monacoLoaded) {
                                clearInterval(checkLoaded);
                                resolve();
                            }
                        }, 100);
                        return;
                    }
                    
                    monacoLoading = true;
                    
                    // Load Monaco Editor script
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs/loader.js';
                    script.onload = () => {
                        // Configure and load Monaco
                        require.config({ 
                            paths: { 
                                'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs' 
                            } 
                        });
                        
                        require(['vs/editor/editor.main'], () => {
                            monacoLoaded = true;
                            monacoLoading = false;
                            console.log('Monaco Editor loaded successfully');
                            resolve();
                        }, (err) => {
                            monacoLoading = false;
                            console.error('Failed to load Monaco Editor:', err);
                            reject(err);
                        });
                    };
                    script.onerror = () => {
                        monacoLoading = false;
                        console.error('Failed to load Monaco Editor loader');
                        reject(new Error('Failed to load Monaco Editor loader'));
                    };
                    document.head.appendChild(script);
                });
            }

            // Initialize Monaco when available
            function initMonaco() {
                if (typeof monaco !== 'undefined' && !monacoEditor) {
                    monacoEditor = monaco.editor.create(document.getElementById('monacoContainer'), {
                        value: '{}',
                        language: 'json',
                        theme: 'vs-light',
                        automaticLayout: true,
                        minimap: { enabled: false },
                        scrollBeyondLastLine: false
                    });
                    
                    // Make Monaco editor accessible globally for sprite properties editor
                    window.monacoEditor = monacoEditor;
                }
            }

            const origUpdateLayersList = CanvasEditor.prototype.updateLayersList;
            CanvasEditor.prototype.updateLayersList = function() {
                origUpdateLayersList.call(this);
                // Add edit as JSON button to each layer
                const layersList = document.getElementById('layersList');
                Array.from(layersList.children).forEach((layerDiv, idx) => {
                    const btn = document.createElement('button');
                    btn.textContent = '{ }';
                    btn.title = 'Edit as JSON';
                    btn.className = 'ml-1 text-xs bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded';
                    btn.onclick = async (e) => {
                        e.stopPropagation();
                        const layer = this.layers[idx];
                        const jsonString = JSON.stringify(layer, null, 2);
                        
                        document.querySelector('#jsonModal h2').textContent = `Edit Layer JSON: ${layer.name}`;
                        
                        // Show modal first
                        modal.style.display = 'block';
                        
                        // Try to load Monaco
                        try {
                            await loadMonaco();
                            initMonaco();
                            
                            if (monacoEditor) {
                                monacoEditor.setValue(jsonString);
                                document.getElementById('monacoContainer').style.display = 'block';
                                document.getElementById('jsonEditor').style.display = 'none';
                                monacoEditor.layout(); // Ensure proper layout
                            } else {
                                throw new Error('Monaco failed to initialize');
                            }
                        } catch (error) {
                            console.warn('Monaco Editor not available, using textarea:', error);
                            document.getElementById('jsonEditor').value = jsonString;
                            document.getElementById('monacoContainer').style.display = 'none';
                            document.getElementById('jsonEditor').style.display = 'block';
                        }
                        
                        // Save handler
                        const saveHandler = () => {
                            try {
                                const newJsonString = monacoEditor && monacoLoaded ? 
                                    monacoEditor.getValue() : 
                                    document.getElementById('jsonEditor').value;
                                const newLayer = JSON.parse(newJsonString);
                                
                                // Validate layer structure
                                if (!newLayer.id || !newLayer.name || !newLayer.type) {
                                    throw new Error('Layer must have id, name, and type properties');
                                }
                                
                                this.layers[idx] = newLayer;
                                if (this.activeLayer && this.activeLayer.id === newLayer.id) {
                                    this.activeLayer = newLayer;
                                }
                                modal.style.display = 'none';
                                this.updateLayersList();
                                this.updateToolsPanel();
                                this.redraw();
                                
                                // Clean up
                                document.getElementById('jsonSave').removeEventListener('click', saveHandler);
                                document.getElementById('jsonCancel').removeEventListener('click', cancelHandler);
                            } catch (err) {
                                alert('Invalid JSON: ' + err.message);
                            }
                        };
                        
                        const cancelHandler = () => {
                            modal.style.display = 'none';
                            // Clean up
                            document.getElementById('jsonSave').removeEventListener('click', saveHandler);
                            document.getElementById('jsonCancel').removeEventListener('click', cancelHandler);
                        };
                        
                        document.getElementById('jsonSave').addEventListener('click', saveHandler);
                        document.getElementById('jsonCancel').addEventListener('click', cancelHandler);
                    };
                    layerDiv.querySelector('.flex').appendChild(btn);
                });
            };
        })();

        const editor = new CanvasEditor();
    </script>
</body>
</html></div>