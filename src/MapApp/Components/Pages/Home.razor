@page "/"
@using System.Text.Json
@using GridEditorLib
@using MapsLib.Services

@inject MapService mapService
@inject MapGridJsInterop mapGrid
@rendermode InteractiveServer

<div>
    <div>
        <button @onclick="EmptyAsync">Empty</button>
        <button @onclick="LoadAsync">Load</button>
        <button @onclick="SaveAsync">Save</button>
        <button @onclick="RotateLeft90Async">Rotate Left 90°</button>
        <button @onclick="RotateLeft180Async">Rotate Left 180°</button>
        <TileSelector @bind-Type="@TileType"></TileSelector>
    </div>
    <div>
        <MapGrid></MapGrid>
    </div>
</div>
@code {
    private string filename = @"D:\MarcoSoft\Thrust\src\Game\assets\js\levels\07\Data.json";

    private DotNetObjectReference<Home>? pageProxy;

    private byte tileType;

    private LevelConfig? levelConfig;

    public byte TileType {
        get => tileType;
        set {
            tileType = value;
            mapGrid.SetTileTypeAsync(tileType).Wait();
        }
    }

    async Task EmptyAsync()
    {
        try
        {
            await mapGrid.SetTileTypeAsync(0);
            levelConfig = new LevelConfig
            {
                CellSize = 40,
                Gravity = 0.05M,
                ShipX = 100,
                ShipY = 100,
                GridWidth = 10,
                GridHeight = 10
            };
            await mapGrid.LoadAsync(levelConfig);
        }
        catch(Exception ex)
        {
            Console.WriteLine($"Error during EmptyAsync: {ex.Message}");
        }
    }

    async Task LoadAsync()
    {
        try
        {
            using var stream = new FileStream(filename, FileMode.Open);
            var lc = await mapService.LoadAsync(stream);
            await mapGrid.LoadAsync(lc);
            levelConfig = lc;
            stream.Close();
        }
        catch(Exception ex)
        {
            Console.WriteLine($"Error during LoadAsync: {ex.Message}");
        }   
    }

    async Task SaveAsync()
    {
        using var stream = new FileStream(filename, FileMode.Create);
        await mapService.SaveAsync(stream, levelConfig);
        stream.Close();
    }

    async Task RotateLeft90Async()
    {
        try
        {
            var lc = levelConfig.RotateLeft90();
            await mapGrid.LoadAsync(lc);
            levelConfig = lc;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during RotateLeft90Async: {ex.Message}");
        }
    }

    async Task RotateLeft180Async()
    {
        try
        {
            var lc = levelConfig.RotateLeft180();
            await mapGrid.LoadAsync(lc);
            levelConfig = lc;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during RotateLeft90Async: {ex.Message}");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                pageProxy = DotNetObjectReference.Create(this);
                var tilesetImage = File.ReadAllBytes(filename);
                await mapGrid.SetupAsync(pageProxy, "canvas", tilesetImage);
                await EmptyAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error during OnAfterRenderAsync: {ex.Message}");
            }
        }
    }

    [JSInvokable]
    public async Task SetXYAsync(JsonElement x, JsonElement y, JsonElement tileType)
    {
        if (x.TryGetInt32(out var xValue) && y.TryGetInt32(out var yValue) && tileType.TryGetByte(out var tileTypeValue))
        {
            levelConfig.Grid[yValue * levelConfig.GridWidth + xValue] = tileTypeValue;
        }
    }

    public void Dispose() => pageProxy?.Dispose();
}